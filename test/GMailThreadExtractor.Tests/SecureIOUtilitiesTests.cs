using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Threading.Tasks;
using FluentAssertions;
using Shared;

namespace GMailThreadExtractor.Tests;

public class SecureIOUtilitiesTests : IDisposable
{
    private readonly string _testDirectory;
    private readonly List<string> _tempFiles;

    public SecureIOUtilitiesTests()
    {
        _testDirectory = Path.Combine(Path.GetTempPath(), $"secure_io_tests_{Guid.NewGuid():N}");
        Directory.CreateDirectory(_testDirectory);
        _tempFiles = new List<string>();
    }

    public void Dispose()
    {
        foreach (var file in _tempFiles.Where(File.Exists))
        {
            try { File.Delete(file); } catch { /* Ignore cleanup errors */ }
        }

        if (Directory.Exists(_testDirectory))
        {
            try { Directory.Delete(_testDirectory, true); } catch { /* Ignore cleanup errors */ }
        }
    }

    [Fact]
    public void CreateSecureTempFile_WithValidPath_ShouldCreateFileWithSecurePermissions()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "test_secure_file.tmp");
        _tempFiles.Add(filePath);

        // Act
        using FileStream stream = SecureIOUtilities.CreateSecureTempFile(filePath, bufferSize: 8192);

        // Assert
        stream.Should().NotBeNull();
        stream.CanRead.Should().BeTrue();
        stream.CanWrite.Should().BeTrue();
        File.Exists(filePath).Should().BeTrue();

        // Verify file permissions are secure
        VerifySecurePermissions(filePath);
    }

    [Fact]
    public void CreateSecureTempFile_WithAutoGeneratedPath_ShouldCreateUniqueFile()
    {
        // Act
        var (stream1, filePath1) = SecureIOUtilities.CreateSecureTempFile("test_prefix", ".test");
        var (stream2, filePath2) = SecureIOUtilities.CreateSecureTempFile("test_prefix", ".test");

        _tempFiles.Add(filePath1);
        _tempFiles.Add(filePath2);

        // Assert
        using (stream1)
        using (stream2)
        {
            stream1.Should().NotBeNull();
            stream2.Should().NotBeNull();
            filePath1.Should().NotBe(filePath2); // Should be unique

            File.Exists(filePath1).Should().BeTrue();
            File.Exists(filePath2).Should().BeTrue();

            filePath1.Should().Contain("test_prefix");
            filePath1.Should().EndWith(".test");
            filePath2.Should().Contain("test_prefix");
            filePath2.Should().EndWith(".test");
        }

        // Verify both files have secure permissions
        VerifySecurePermissions(filePath1);
        VerifySecurePermissions(filePath2);
    }

    [Fact]
    public void CreateSecureTempFile_WithNullOrEmptyPath_ShouldThrow()
    {
        // Act & Assert
        var act1 = () => SecureIOUtilities.CreateSecureTempFile(null!, bufferSize: 8192);
        var act2 = () => SecureIOUtilities.CreateSecureTempFile("", bufferSize: 8192);
        var act3 = () => SecureIOUtilities.CreateSecureTempFile("   ", bufferSize: 8192);

        act1.Should().Throw<ArgumentException>().WithMessage("*cannot be null or empty*");
        act2.Should().Throw<ArgumentException>().WithMessage("*cannot be null or empty*");
        act3.Should().Throw<ArgumentException>().WithMessage("*cannot be null or empty*");
    }

    [Fact]
    public void CreateSecureTempFile_WithInvalidBufferSize_ShouldThrow()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "test.tmp");

        // Act & Assert
        var act1 = () => SecureIOUtilities.CreateSecureTempFile(filePath, bufferSize: 0);
        var act2 = () => SecureIOUtilities.CreateSecureTempFile(filePath, bufferSize: -1);

        act1.Should().Throw<ArgumentOutOfRangeException>().WithMessage("*Buffer size must be positive*");
        act2.Should().Throw<ArgumentOutOfRangeException>().WithMessage("*Buffer size must be positive*");
    }

    [Fact]
    public void CreateSecureTempFile_WithInvalidDirectory_ShouldThrow()
    {
        // Arrange
        var invalidPath = Path.Combine("C:\\NonexistentDirectory", "test.tmp");

        // Act & Assert
        var act = () => SecureIOUtilities.CreateSecureTempFile(invalidPath, bufferSize: 8192);
        act.Should().Throw<Exception>(); // Could be DirectoryNotFoundException or similar
    }

    [Fact]
    public void SetSecureFilePermissions_WithExistingFile_ShouldSetPermissions()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "test_permissions.tmp");
        File.WriteAllText(filePath, "test content");
        _tempFiles.Add(filePath);

        // Act
        SecureIOUtilities.SetSecureFilePermissions(filePath);

        // Assert
        VerifySecurePermissions(filePath);
    }

    [Fact]
    public void SetSecureFilePermissions_WithNonexistentFile_ShouldThrow()
    {
        // Arrange
        var nonexistentPath = Path.Combine(_testDirectory, "nonexistent.tmp");

        // Act & Assert
        var act = () => SecureIOUtilities.SetSecureFilePermissions(nonexistentPath);
        act.Should().Throw<FileNotFoundException>();
    }

    [Fact]
    public void SetSecureFilePermissions_WithNullOrEmptyPath_ShouldThrow()
    {
        // Act & Assert
        var act1 = () => SecureIOUtilities.SetSecureFilePermissions(null!);
        var act2 = () => SecureIOUtilities.SetSecureFilePermissions("");

        act1.Should().Throw<ArgumentException>().WithMessage("*cannot be null or empty*");
        act2.Should().Throw<ArgumentException>().WithMessage("*cannot be null or empty*");
    }

    [Fact]
    public void SafeDeleteFile_WithExistingFile_ShouldDeleteAndReturnTrue()
    {
        // Arrange
        var filePath = Path.Combine(_testDirectory, "file_to_delete.tmp");
        File.WriteAllText(filePath, "test content");

        // Act
        var result = SecureIOUtilities.SafeDeleteFile(filePath);

        // Assert
        result.Should().BeTrue();
        File.Exists(filePath).Should().BeFalse();
    }

    [Fact]
    public void SafeDeleteFile_WithNonexistentFile_ShouldReturnTrue()
    {
        // Arrange
        var nonexistentPath = Path.Combine(_testDirectory, "nonexistent.tmp");

        // Act
        var result = SecureIOUtilities.SafeDeleteFile(nonexistentPath);

        // Assert
        result.Should().BeTrue(); // Should return true for files that don't exist
    }

    [Fact]
    public void SafeDeleteFile_WithNullOrEmptyPath_ShouldReturnTrue()
    {
        // Act & Assert
        SecureIOUtilities.SafeDeleteFile(null!).Should().BeTrue();
        SecureIOUtilities.SafeDeleteFile("").Should().BeTrue();
        SecureIOUtilities.SafeDeleteFile("   ").Should().BeTrue();
    }

    [Fact]
    public async Task CreateSecureTempFile_ShouldAllowWriteAndRead()
    {
        // Arrange
        var testContent = "This is test content for secure file operations";
        var (stream, filePath) = SecureIOUtilities.CreateSecureTempFile("test_content", ".txt");
        _tempFiles.Add(filePath);

        // Act & Assert
        using (stream)
        {
            var contentBytes = System.Text.Encoding.UTF8.GetBytes(testContent);
            await stream.WriteAsync(contentBytes);
            await stream.FlushAsync();

            stream.Position = 0;
            var buffer = new byte[contentBytes.Length];
            var bytesRead = await stream.ReadAsync(buffer);

            bytesRead.Should().Be(contentBytes.Length);
            var readContent = System.Text.Encoding.UTF8.GetString(buffer);
            readContent.Should().Be(testContent);
        }

        // Verify file still exists and has correct content
        File.Exists(filePath).Should().BeTrue();
        var fileContent = await File.ReadAllTextAsync(filePath);
        fileContent.Should().Be(testContent);
    }

    [Fact]
    public void CreateSecureTempFile_WithCustomBufferSize_ShouldRespectBufferSize()
    {
        // Arrange
        var customBufferSize = 16384; // 16KB
        var filePath = Path.Combine(_testDirectory, "custom_buffer.tmp");
        _tempFiles.Add(filePath);

        // Act
        using var stream = SecureIOUtilities.CreateSecureTempFile(filePath, customBufferSize);

        // Assert
        stream.Should().NotBeNull();
        // Note: We can't directly verify buffer size, but we can verify the stream works
        stream.CanWrite.Should().BeTrue();
        stream.CanRead.Should().BeTrue();
    }

    [Fact]
    public void CreateSecureTempFile_ShouldCleanupOnFailure()
    {
        // This test is platform-specific and harder to simulate reliably
        // In a real scenario, we would need to mock file system operations
        // For now, we'll test the basic cleanup behavior

        var invalidPath = RuntimeInformation.IsOSPlatform(OSPlatform.Windows)
            ? "CON:" // Invalid Windows filename
            : "/dev/null/invalid"; // Invalid Unix path

        // Act & Assert
        var act = () => SecureIOUtilities.CreateSecureTempFile(invalidPath, bufferSize: 8192);
        act.Should().Throw<Exception>();

        // File should not exist if creation failed
        File.Exists(invalidPath).Should().BeFalse();
    }

    private void VerifySecurePermissions(string filePath)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            VerifyWindowsPermissions(filePath);
        }
        else
        {
            VerifyUnixPermissions(filePath);
        }
    }

    private void VerifyWindowsPermissions(string filePath)
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return;

        try
        {
            var fileInfo = new FileInfo(filePath);
            var fileSecurity = fileInfo.GetAccessControl();
            var accessRules = fileSecurity.GetAccessRules(true, false, typeof(SecurityIdentifier));
            var currentUser = WindowsIdentity.GetCurrent();

            // Should have access rules
            accessRules.Should().NotBeNull();
            accessRules.Count.Should().BeGreaterThan(0);

            // Should have full control for current user
            var hasFullControlForCurrentUser = false;
            foreach (FileSystemAccessRule rule in accessRules)
            {
                if (rule.IdentityReference.Equals(currentUser.User) &&
                    rule.FileSystemRights.HasFlag(FileSystemRights.FullControl) &&
                    rule.AccessControlType == AccessControlType.Allow)
                {
                    hasFullControlForCurrentUser = true;
                    break;
                }
            }

            hasFullControlForCurrentUser.Should().BeTrue("Current user should have full control");
        }
        catch (Exception ex)
        {
            // If we can't verify permissions, at least ensure the file exists and is accessible
            File.Exists(filePath).Should().BeTrue();
            File.ReadAllText(filePath).Should().NotBeNull(); // Should be able to read
            throw new InvalidOperationException($"Could not verify Windows permissions: {ex.Message}", ex);
        }
    }

    private void VerifyUnixPermissions(string filePath)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return;

        try
        {
            var fileMode = File.GetUnixFileMode(filePath);

            // Should have read and write for owner
            fileMode.Should().HaveFlag(UnixFileMode.UserRead, "Owner should have read permission");
            fileMode.Should().HaveFlag(UnixFileMode.UserWrite, "Owner should have write permission");

            // Should NOT have permissions for group or others
            fileMode.Should().NotHaveFlag(UnixFileMode.GroupRead, "Group should not have read permission");
            fileMode.Should().NotHaveFlag(UnixFileMode.GroupWrite, "Group should not have write permission");
            fileMode.Should().NotHaveFlag(UnixFileMode.OtherRead, "Others should not have read permission");
            fileMode.Should().NotHaveFlag(UnixFileMode.OtherWrite, "Others should not have write permission");
        }
        catch (Exception ex)
        {
            // If we can't verify permissions, at least ensure the file exists and is accessible
            File.Exists(filePath).Should().BeTrue();
            File.ReadAllText(filePath).Should().NotBeNull(); // Should be able to read
            throw new InvalidOperationException($"Could not verify Unix permissions: {ex.Message}", ex);
        }
    }
}